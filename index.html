<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>World Words Hub ‚Äî Pattern Stacking Engine.</title>

  <style>
    :root {
      --bg: #070b14;
      --panel: #0f172a;
      --accent: #7c3aed;
      --accent-glow: rgba(124, 58, 237, 0.3);
      --text-main: #e2e8f0;
      --text-muted: #94a3b8;
      --border: rgba(255, 255, 255, 0.06);
      --glass: rgba(15, 23, 42, 0.6);
      --danger:#ff6b6b;
      --good:#22c55e;
      --shadow: rgba(0,0,0,0.28);
    }

    body[data-theme="light"]{
      --bg: #f6f7fb;
      --panel: #ffffff;
      --accent: #6d28d9;
      --accent-glow: rgba(109, 40, 217, 0.22);
      --text-main: #0b1220;
      --text-muted: #475569;
      --border: rgba(15, 23, 42, 0.10);
      --glass: rgba(255, 255, 255, 0.75);
      --danger:#dc2626;
      --good:#16a34a;
      --shadow: rgba(2,6,23,0.10);
    }

    * { box-sizing: border-box; font-family: 'Inter', system-ui, -apple-system, sans-serif; }
    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--text-main);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 1rem 1.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      z-index: 10;
      gap: 12px;
    }

    .header-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    .memory-pill {
      background: rgba(124, 58, 237, 0.10);
      border: 1px solid rgba(124, 58, 237, 0.55);
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 0.82rem;
      color: var(--accent);
      font-weight: 800;
      white-space: nowrap;
    }

    .dashboard {
      display: grid;
      grid-template-columns: 320px 1fr;
      flex: 1;
      overflow: hidden;
    }

    section {
      padding: 1.5rem;
      overflow-y: auto;
      border-right: 1px solid var(--border);
      scrollbar-width: thin;
      scrollbar-color: var(--accent) var(--bg);
    }
    #feed-view { border-right: none; }

    h2 {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-muted);
      margin: 0 0 1rem;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1.2rem;
      margin-bottom: 1rem;
      transition: 0.2s;
      box-shadow: 0 10px 24px var(--shadow);
    }
    .card:hover { border-color: rgba(124,58,237,0.45); }

    .muted{ color: var(--text-muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }

    .tag-row { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }
    .tag {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-decoration: none;
      user-select: none;
      cursor: pointer;
      display:inline-block;
      transition: 0.15s;
      white-space: nowrap;
    }
    body[data-theme="light"] .tag{
      background: rgba(2, 6, 23, 0.03);
    }
    .tag:hover { background: rgba(124, 58, 237, 0.15); color: var(--text-main); }
    .tag.good { border-color: rgba(34,197,94,0.35); color: rgba(34,197,94,0.95); }
    .tag.bad  { border-color: rgba(255,107,107,0.35); color: rgba(255,107,107,0.95); }

    /* Brand tints */
    .tag.brand-yt   { border-color: rgba(255,0,0,0.35);     color: rgba(255,110,110,0.95); }
    .tag.brand-wiki { border-color: rgba(180,180,180,0.35); color: rgba(225,225,225,0.95); }
    .tag.brand-wikt { border-color: rgba(90,160,255,0.35);  color: rgba(170,210,255,0.95); }
    .tag.brand-dict { border-color: rgba(124,58,237,0.55);  color: rgba(205,175,255,0.95); }
    .tag.brand-web  { border-color: rgba(34,197,94,0.35);   color: rgba(34,197,94,0.95); }
    .tag.brand-thes { border-color: rgba(255,193,7,0.35);   color: rgba(255,220,130,0.95); }
    .tag.brand-ency { border-color: rgba(148,163,184,0.35); color: rgba(226,232,240,0.92); }
    .tag.brand-lens { border-color: rgba(124,58,237,0.35);  color: rgba(205,175,255,0.95); }
    .tag.brand-rhyme{ border-color: rgba(56,189,248,0.35);  color: rgba(125,211,252,0.95); }

    body[data-theme="light"] .tag.brand-wiki { color: rgba(15,23,42,0.85); border-color: rgba(15,23,42,0.25); }
    body[data-theme="light"] .tag.brand-wikt { color: rgba(29,78,216,0.90); border-color: rgba(29,78,216,0.25); }
    body[data-theme="light"] .tag.brand-dict { color: rgba(109,40,217,0.95); border-color: rgba(109,40,217,0.35); }
    body[data-theme="light"] .tag.brand-thes { color: rgba(161,98,7,0.95);  border-color: rgba(161,98,7,0.25); }
    body[data-theme="light"] .tag.brand-ency { color: rgba(71,85,105,0.95); border-color: rgba(71,85,105,0.25); }
    body[data-theme="light"] .tag.brand-lens { color: rgba(109,40,217,0.95); border-color: rgba(109,40,217,0.25); }
    body[data-theme="light"] .tag.brand-rhyme{ color: rgba(3,105,161,0.95); border-color: rgba(3,105,161,0.25); }

    .search-container { display: flex; justify-content: center; margin-bottom: 1rem; }
    .search-wrapper {
      display: flex;
      align-items: center;
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 6px 6px 18px;
      width: 100%;
      max-width: 760px;
      transition: 0.3s;
      backdrop-filter: blur(10px);
      gap: 10px;
    }
    .search-wrapper:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 20px var(--accent-glow);
    }
    #mainSearch {
      background: transparent;
      border: none;
      color: var(--text-main);
      font-size: 1rem;
      flex: 1;
      outline: none;
      min-width: 120px;
    }

    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 9px 16px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 900;
      text-transform: uppercase;
      font-size: 0.72rem;
      letter-spacing: 1px;
      white-space: nowrap;
    }
    .btn.secondary {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-main);
      font-weight: 800;
    }
    .btn:disabled{ opacity:0.55; cursor:not-allowed; }

    .pill-btn{
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 8px 12px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 900;
      font-size: 0.75rem;
      letter-spacing: 1px;
      display:flex;
      align-items:center;
      gap:8px;
      transition: 0.15s;
      user-select:none;
      white-space: nowrap;
    }
    .pill-btn:hover{
      border-color: rgba(124,58,237,0.45);
      box-shadow: 0 0 16px var(--accent-glow);
    }

    .select{
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 8px 34px 8px 12px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 0.75rem;
      letter-spacing: 1px;
      cursor: pointer;
      position: relative;
    }
    .select-wrap{ position: relative; display:inline-block; }
    .select-wrap:after{
      content:"‚ñæ";
      position:absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-muted);
      pointer-events:none;
      font-weight: 900;
    }

    footer {
      padding: 0.8rem;
      text-align: center;
      font-size: 0.75rem;
      color: var(--text-muted);
      border-top: 1px solid var(--border);
      background: var(--bg);
    }

    .mobile-nav {
      display: none;
      background: var(--panel);
      padding: 10px;
      border-top: 1px solid var(--border);
      justify-content: space-around;
      gap: 8px;
    }

    @media (max-width: 1024px) {
      .dashboard { grid-template-columns: 1fr; }
      .side-panel { display: none; }
      .active-view { display: block !important; }
      .mobile-nav { display: flex; }
      section { border-right: none; }
    }

    .wordHero{ text-align:center; margin-bottom: 1rem; }
    .wordHero h1{
      font-size: 3.0rem;
      margin:0;
      letter-spacing: 8px;
      font-weight: 900;
      filter: drop-shadow(0 0 10px var(--accent-glow));
    }

    .wordListGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 10px;
      margin-top: 10px;
    }
    @media (min-width: 900px){
      .wordListGrid{ grid-template-columns: repeat(4, minmax(0,1fr)); }
    }
    .wordBtn{
      width:100%;
      text-align:left;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: 0.15s;
      font-weight: 900;
      letter-spacing: 0.3px;
    }
    body[data-theme="light"] .wordBtn{ background: rgba(2,6,23,0.03); }
    .wordBtn:hover{ border-color: rgba(124,58,237,0.55); transform: translateY(-1px); }

    .divider{ margin: 18px 0; height: 1px; background: var(--border); }

    .savedItem{
      padding: 12px 4px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
    }
    .savedItem:hover{ background: rgba(255,255,255,0.02); border-radius: 10px; padding-left: 10px; padding-right: 10px; }
    body[data-theme="light"] .savedItem:hover{ background: rgba(2,6,23,0.03); }
    .savedWord{ font-weight: 1000; letter-spacing: 1px; }
    .savedMeta{ font-size: 0.8rem; opacity: 0.65; }

    /* Main-word links row (compact) */
    .mainLinksWrap{
      display:flex;
      justify-content:center;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      margin-top: 12px;
    }

    /* Collapsible Lens box */
    .lensBox{
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      background: linear-gradient(135deg, rgba(124, 58, 237, 0.08), transparent);
    }

    /* Notes search */
    .notes-search {
      width: 100%;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--glass);
      color: var(--text-main);
      outline: none;
      margin-bottom: 12px;
      backdrop-filter: blur(10px);
    }
    .notes-search:focus {
      border-color: var(--accent);
      box-shadow: 0 0 18px var(--accent-glow);
    }

    /* Loading / Running Stack animation */
    .status-loading {
      display: inline-block;
      padding: 8px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(255,255,255,0.03);
      position: relative;
      overflow: hidden;
      animation: breathe 1.7s ease-in-out infinite;
      box-shadow: 0 0 22px rgba(124, 58, 237, 0.18);
    }
    body[data-theme="light"] .status-loading{
      background: rgba(2,6,23,0.03);
      border-color: rgba(2,6,23,0.10);
    }
    .status-loading::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: linear-gradient(90deg,
        rgba(34,197,94,0.30),
        rgba(56,189,248,0.30),
        rgba(124,58,237,0.30),
        rgba(236,72,153,0.30),
        rgba(255,193,7,0.30),
        rgba(34,197,94,0.30)
      );
      filter: blur(10px);
      opacity: 0.75;
      animation: rainbow 2.2s linear infinite;
      z-index: 0;
    }
    .status-loading > span{
      position: relative;
      z-index: 1;
      font-weight: 900;
      letter-spacing: 0.6px;
    }
    @keyframes breathe{
      0% { transform: translateY(0); box-shadow: 0 0 18px rgba(124,58,237,0.18); }
      50% { transform: translateY(-1px); box-shadow: 0 0 30px rgba(124,58,237,0.30); }
      100% { transform: translateY(0); box-shadow: 0 0 18px rgba(124,58,237,0.18); }
    }
    @keyframes rainbow{
      0% { transform: translateX(-18%); }
      100% { transform: translateX(18%); }
    }

    /* Inline mini form for restricted notice */
    .inline-form{
      display:flex;
      gap:10px;
      justify-content:center;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 10px;
    }
    .email-input{
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--glass);
      color: var(--text-main);
      outline:none;
      min-width: 240px;
      max-width: 360px;
      width: 70%;
      backdrop-filter: blur(10px);
    }
    .email-input:focus{
      border-color: var(--accent);
      box-shadow: 0 0 16px var(--accent-glow);
    }
  </style>
</head>

<body>
<header>
  <div>
    <h1 style="font-size: 1.05rem; margin: 0; letter-spacing: 1px;">WORLD WORDS HUB</h1>
    <p id="subtitleLine" style="font-size: 0.65rem; margin: 2px 0 0; color: var(--text-muted);">Decode Language. Find Patterns.</p>
  </div>

  <div class="header-right">
    <div class="select-wrap" title="Language">
      <select class="select" id="langSelect" aria-label="Language">
        <option value="en">EN</option>
        <option value="es">ES</option>
        <option value="mix">EN + ES</option>
        <option value="de">DE</option>
        <option value="en_de">EN + DE</option>
      </select>
    </div>

    <button class="pill-btn" id="themeToggle" title="Toggle theme" aria-label="Toggle theme">üåô Dark</button>

    <div class="memory-pill" id="memoryPill">üß† Memory: 0 saved</div>
  </div>
</header>

<main class="dashboard">
  <!-- NOTES -->
  <section id="notes-view" class="side-panel">
    <h2 id="notesTitle">Notes</h2>

    <input id="notesSearch" class="notes-search" placeholder="Search saved words‚Ä¶" autocomplete="off" />

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div class="muted" style="font-size:0.9rem;" id="notesHint">
          Tap a saved item to load it in the Hub.
        </div>
        <button class="btn secondary" id="clearSaved">Clear Outputs</button>
      </div>
      <div id="savedRuns" style="margin-top: 12px;"></div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div class="muted" style="font-size:0.9rem;">
          Saved scorecards (single words you liked).
        </div>
        <button class="btn secondary" id="clearSavedCards">Clear Cards</button>
      </div>
      <div id="savedCards" style="margin-top: 12px;"></div>
    </div>
  </section>

  <!-- HUB -->
  <section id="feed-view" class="active-view">
    <div class="search-container">
      <div class="search-wrapper">
        <input type="text" id="mainSearch" placeholder="Type a real dictionary word‚Ä¶" autocomplete="off" />
        <button class="btn" id="executeBtn">Execute</button>
        <button class="btn secondary" id="clearBtn">Clear</button>
      </div>
    </div>

    <div class="wordHero">
      <p class="muted" id="resultsForLabel" style="margin:0; letter-spacing:2px; text-transform:uppercase; font-size:0.8rem; color: var(--accent);">
        Results for:
      </p>
      <h1 id="displayWord">‚Äî</h1>

      <div class="mainLinksWrap" id="mainWordLinks" style="display:none;"></div>

      <p id="statusLine" class="muted" style="margin:10px 0 0;">Enter a word and press Execute.</p>

      <div id="restrictedBlock" style="display:none; margin-top: 10px;">
        <div class="muted" style="max-width: 760px; margin: 0 auto; line-height:1.6;">
          <b style="color: var(--danger);">This term cannot be produced at this time.</b><br/>
          World Words Hub is continuously evolving. If you want a heads-up when updates drop, leave your email.
        </div>
        <div class="inline-form">
          <input id="emailInput" class="email-input" type="email" placeholder="you@example.com" />
          <button class="btn" id="emailSaveBtn" type="button">Notify Me</button>
        </div>
        <div class="muted" id="emailSavedMsg" style="margin-top:8px; font-size:0.85rem; display:none;">
          ‚úÖ Saved locally for now (we‚Äôll wire automation later).
        </div>
      </div>

      <div style="display:flex; gap:10px; justify-content:center; margin-top:14px; flex-wrap:wrap;">
        <button class="btn secondary" id="moreBtn" disabled>Generate More</button>
        <button class="btn secondary" id="saveBtn" disabled>Save Output</button>
      </div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div>
          <div class="muted" id="generatedWordsLabel" style="font-size:0.8rem; letter-spacing:2px; text-transform:uppercase;">Generated Words</div>
          <div class="muted" id="generatedWordsHint" style="font-size:0.85rem;">Click one word ‚Äî it will show ONE card below.</div>
        </div>
        <div id="dictBadge" class="tag">Awaiting input‚Ä¶</div>
      </div>

      <div id="wordList" class="wordListGrid" style="margin-top:14px;"></div>

      <div class="divider"></div>

      <div id="cardsArea" style="margin-top:12px;"></div>
    </div>

    <div style="margin-top: 1.2rem; opacity: 0.95;">
      <h2 id="synthesisTitle">Synthesis</h2>
      <div class="card" style="background: linear-gradient(135deg, rgba(124, 58, 237, 0.10), transparent);">
        <p id="synthesisText" style="line-height: 1.6; font-style: italic; margin:0;">
          "The engine identifies patterns. The human determines truth."
        </p>
      </div>
    </div>
  </section>
</main>

<nav class="mobile-nav">
  <button class="btn" style="padding:8px 15px;" onclick="showView('notes-view')" id="mobileNotes">Notes</button>
  <button class="btn" style="padding:8px 15px;" onclick="showView('feed-view')" id="mobileHub">Hub</button>
</nav>

<footer>
  ¬© 2026 World Words Hub ‚Ä¢ Powered by CROW Lens.
  <a href="https://www.bluecomet.work" target="_blank" rel="noopener noreferrer">üåê</a>
  <span id="footerLine">A word is not just a word ‚Äî it‚Äôs a container of patterns, sounds, and meanings.</span>
</footer>

<script>
  const $ = (id)=>document.getElementById(id);

  const mainSearch = $("mainSearch");
  const executeBtn = $("executeBtn");
  const clearBtn   = $("clearBtn");
  const moreBtn    = $("moreBtn");
  const saveBtn    = $("saveBtn");

  const displayWord = $("displayWord");
  const statusLine  = $("statusLine");
  const synthesisText = $("synthesisText");

  const wordListEl  = $("wordList");
  const cardsArea   = $("cardsArea");
  const dictBadge   = $("dictBadge");

  const savedRunsEl = $("savedRuns");
  const savedCardsEl = $("savedCards");
  const clearSavedBtn = $("clearSaved");
  const clearSavedCardsBtn = $("clearSavedCards");
  const memoryPill  = $("memoryPill");

  const langSelect  = $("langSelect");
  const themeToggle = $("themeToggle");

  const subtitleLine = $("subtitleLine");
  const resultsForLabel = $("resultsForLabel");
  const generatedWordsLabel = $("generatedWordsLabel");
  const generatedWordsHint = $("generatedWordsHint");
  const synthesisTitle = $("synthesisTitle");
  const footerLine = $("footerLine");

  const notesTitle = $("notesTitle");
  const notesHint  = $("notesHint");
  const mobileNotes = $("mobileNotes");
  const mobileHub   = $("mobileHub");

  const mainWordLinks = $("mainWordLinks");

  const notesSearch = $("notesSearch");

  const restrictedBlock = $("restrictedBlock");
  const emailInput = $("emailInput");
  const emailSaveBtn = $("emailSaveBtn");
  const emailSavedMsg = $("emailSavedMsg");

  const PAGE_SIZE = 20;
  const NOVELTY_MIN = 0.20;

  const MEM_KEY = "wwh_saved_runs_v2";
  const MEM_CARDS_KEY = "wwh_saved_cards_v1";
  const MEM_EMAILS_KEY = "wwh_emails_v1";
  const THEME_KEY = "wwh_theme_v1";
  const LANG_KEY  = "wwh_lang_v1";

  // --------------------
  // i18n (UI only) (kept simple)
  // --------------------
  const I18N = {
    en: {
      subtitle: "Decode Language. Find Patterns.",
      placeholder: "Type a real dictionary word‚Ä¶",
      execute: "Execute",
      clear: "Clear",
      more: "Generate More",
      save: "Save Output",
      resultsFor: "Results for:",
      generatedWords: "Generated Words",
      generatedHint: "Click one word ‚Äî it will show ONE card below.",
      synthesis: "Synthesis",
      synthDefault: "\"The engine identifies patterns. The human determines truth.\"",
      awaiting: "Awaiting input‚Ä¶",
      enterAndExecute: "Enter a word and press Execute.",
      cleared: "Cleared. Type a word and press Execute.",
      checkingDict: "Checking dictionary‚Ä¶",
      validating: "Validating input word‚Ä¶",
      runningStack: "Running stack‚Ä¶",
      readyTap: (w)=>`"${w}" ready. Tap any generated word to open its card.`,
      expandedTap: (w)=>`"${w}" expanded. Tap a word to open its card.`,
      expanding: "Expanding outward‚Ä¶",
      stopPoint: "Natural stop point reached: no new high-novelty patterns remain.",
      saved: "Saved output to Notes.",
      savedCard: "Saved scorecard.",
      deletedOne: "Deleted one saved output.",
      deletedCard: "Deleted one saved card.",
      clearedSaved: "Saved outputs cleared.",
      clearedCards: "Saved cards cleared.",
      notes: "Notes",
      notesHint: "Tap a saved item to load it in the Hub.",
      mobileNotes: "Notes",
      mobileHub: "Hub",
      footer: "A word is not just a word ‚Äî it‚Äôs a container of patterns, sounds, and meanings.",
      badgeDictOk: "Dictionary ‚úì",
      badgeDictSoftOk: "Not verified ‚Äî ran anyway",
      badgeNetworkSoft: "Dictionary offline ‚Äî ran anyway",
      themeDark: "üåô Dark",
      themeLight: "‚òÄÔ∏è Light",
      wordNotVerifiedTitle: "This input was not verified by a dictionary API, but the run executed anyway."
    },
    es: {
      subtitle: "Decodifica lenguaje. Encuentra patrones.",
      placeholder: "Escribe una palabra real del diccionario‚Ä¶",
      execute: "Ejecutar",
      clear: "Limpiar",
      more: "Generar m√°s",
      save: "Guardar",
      resultsFor: "Resultados para:",
      generatedWords: "Palabras generadas",
      generatedHint: "Toca una palabra ‚Äî ver√°s UNA tarjeta abajo.",
      synthesis: "S√≠ntesis",
      synthDefault: "\"El motor identifica patrones. El humano determina la verdad.\"",
      awaiting: "Esperando‚Ä¶",
      enterAndExecute: "Escribe una palabra y presiona Ejecutar.",
      cleared: "Listo. Escribe una palabra y presiona Ejecutar.",
      checkingDict: "Verificando diccionario‚Ä¶",
      validating: "Validando palabra‚Ä¶",
      runningStack: "Ejecutando motor‚Ä¶",
      readyTap: (w)=>`"${w}" listo. Toca una palabra generada para ver su tarjeta.`,
      expandedTap: (w)=>`"${w}" expandido. Toca una palabra para ver su tarjeta.`,
      expanding: "Expandiendo‚Ä¶",
      stopPoint: "Punto de parada: no quedan patrones nuevos con alta novedad.",
      saved: "Guardado en Notas.",
      savedCard: "Tarjeta guardada.",
      deletedOne: "Se elimin√≥ un guardado.",
      deletedCard: "Se elimin√≥ una tarjeta.",
      clearedSaved: "Guardados borrados.",
      clearedCards: "Tarjetas borradas.",
      notes: "Notas",
      notesHint: "Toca un guardado para cargarlo en el Hub.",
      mobileNotes: "Notas",
      mobileHub: "Hub",
      footer: "Una palabra no es solo una palabra ‚Äî es un contenedor de patrones, sonidos y significados.",
      badgeDictOk: "Diccionario ‚úì",
      badgeDictSoftOk: "No verificado ‚Äî se ejecut√≥",
      badgeNetworkSoft: "Diccionario sin conexi√≥n ‚Äî se ejecut√≥",
      themeDark: "üåô Oscuro",
      themeLight: "‚òÄÔ∏è Claro",
      wordNotVerifiedTitle: "Esta palabra no fue verificada por el diccionario, pero el motor se ejecut√≥."
    }
  };

  function getUiLang(){
    const v = langSelect.value;
    return (v === "es") ? "es" : "en";
  }
  function t(key, ...args){
    const L = I18N[getUiLang()] || I18N.en;
    const val = L[key];
    return (typeof val === "function") ? val(...args) : val;
  }

  // --------------------
  // State
  // --------------------
  let state = {
    inputWord: "",
    generation: 0,
    used: new Set(),
    lastBatch: [],
    allResults: [],
    poolMeta: new Map(),
    seedCursor: 0,
    running: false,

    activeCardItem: null,
    cardLinkLang: "en",
    mainLinkLang: "en",

    lensOpen: false,

    restricted: false
  };

  function normalizeWord(s){
    return (s||"")
      .toLowerCase()
      .trim()
      .normalize("NFKD")
      .replace(/[^a-z\u00C0-\u017F√±√ë√°√©√≠√≥√∫√º√Å√â√ç√ì√ö√ú√ü'-\s]/g,"")
      .replace(/\s+/g," ")
      .trim();
  }
  function escapeHtml(s){
    return (s||"").replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  function setBadge(text, cls){
    dictBadge.className = "tag" + (cls ? " " + cls : "");
    dictBadge.textContent = text;
  }

  function setLoading(on){
    if(on){
      // wrap text inside span for glow overlay layering
      statusLine.classList.add("status-loading");
      if(!statusLine.querySelector("span")){
        statusLine.innerHTML = `<span>${escapeHtml(statusLine.textContent || t("runningStack"))}</span>`;
      }
    }else{
      statusLine.classList.remove("status-loading");
      // unwrap
      if(statusLine.querySelector("span")){
        statusLine.textContent = statusLine.querySelector("span").textContent;
      }
    }
  }

  function setStatus(msg){
    // If currently in loading mode, update inner span
    if(statusLine.classList.contains("status-loading") && statusLine.querySelector("span")){
      statusLine.querySelector("span").textContent = msg;
    } else {
      statusLine.textContent = msg;
    }
  }

  // --------------------
  // Guardrails (Simple)
  // --------------------
  // Phase 1: block generation for these topic signals (simple, not exhaustive)
  const RESTRICTED_INPUT_ROOTS = [
    // adult
    "porn","porno","pornography","sex","sexual","xxx","erotic","nude","nudity",
    // drugs
    "cocaine","heroin","meth","methamphetamine","lsd","fentanyl","marijuana","weed","drug","drugs",
    // crime / terror / violence
    "terror","terrorism","bomb","extremism","weapon","gun","shoot","shooting","war","violence","violent",
    "murder","kill","killing","robbery","assault","crime","criminal"
  ];

  // Always filtered from generated output (even when input is allowed)
  const HARD_BLOCK_OUTPUT_ROOTS = [
    // minors/exploitation
    "underage","minor","child","children","groom","grooming","traffick","trafficking","exploit","exploitation",
    // sexual assault / non-consensual
    "rape","rapist","molest","molestation","incest","nonconsensual","non-consensual",
    // extreme graphic harm actions (keep it minimal)
    "behead","decapitat","dismember","mutilat"
  ];

  function tokenize(s){
    return normalizeWord(s).split(" ").filter(Boolean);
  }

  function containsAnyRoot(text, roots){
    const tokens = tokenize(text);
    const joined = " " + tokens.join(" ") + " ";
    // token-aware contains; also allow prefix match for inflections (e.g., exploit -> exploitation)
    return roots.some(r => {
      const rr = normalizeWord(r);
      if(!rr) return false;
      // exact token hit
      if(joined.includes(" " + rr + " ")) return true;
      // prefix hit (for inflections): any token starts with root
      return tokens.some(tok => tok.startsWith(rr));
    });
  }

  function isRestrictedInput(word){
    return containsAnyRoot(word, RESTRICTED_INPUT_ROOTS);
  }

  function filterHardBlocked(batch){
    return (batch || []).filter(item => {
      const w = normalizeWord(item.word);
      return !containsAnyRoot(w, HARD_BLOCK_OUTPUT_ROOTS);
    });
  }

  // --------------------
  // Theme
  // --------------------
  function getTheme(){ return localStorage.getItem(THEME_KEY) || "dark"; }
  function setTheme(theme){
    document.body.setAttribute("data-theme", theme);
    localStorage.setItem(THEME_KEY, theme);
    refreshThemeToggleLabel();
  }
  function refreshThemeToggleLabel(){
    const theme = document.body.getAttribute("data-theme") || "dark";
    themeToggle.textContent = (theme === "light") ? t("themeLight") : t("themeDark");
  }
  themeToggle.addEventListener("click", ()=>{
    const cur = document.body.getAttribute("data-theme") || "dark";
    setTheme(cur === "dark" ? "light" : "dark");
  });

  // --------------------
  // Language mode
  // --------------------
  function getLangMode(){ return langSelect.value || "en"; }
  function getCollabPair(){
    const mode = getLangMode();
    if(mode === "mix")   return { a:"en", b:"es", labelA:"EN", labelB:"ES" };
    if(mode === "en_de") return { a:"en", b:"de", labelA:"EN", labelB:"DE" };
    return null;
  }
  function setLangMode(v){
    langSelect.value = v;
    localStorage.setItem(LANG_KEY, v);

    const pair = getCollabPair();
    state.cardLinkLang = pair ? pair.a : (v === "es" ? "es" : v === "de" ? "de" : "en");
    state.mainLinkLang = state.cardLinkLang;

    applyUiText();

    if(state.inputWord) renderMainWordLinks();
    if(state.activeCardItem) openSingleCard(state.activeCardItem, { keepScroll:true });
  }
  langSelect.addEventListener("change", ()=> setLangMode(langSelect.value));

  // --------------------
  // UI text apply
  // --------------------
  function applyUiText(){
    subtitleLine.textContent = t("subtitle");
    mainSearch.placeholder   = t("placeholder");
    executeBtn.textContent   = t("execute");
    clearBtn.textContent     = t("clear");
    moreBtn.textContent      = t("more");
    saveBtn.textContent      = t("save");
    resultsForLabel.textContent = t("resultsFor");
    generatedWordsLabel.textContent = t("generatedWords");
    generatedWordsHint.textContent  = t("generatedHint");
    synthesisTitle.textContent = t("synthesis");
    footerLine.textContent = t("footer");
    notesTitle.textContent = t("notes");
    notesHint.textContent  = t("notesHint");
    mobileNotes.textContent = t("mobileNotes");
    mobileHub.textContent   = t("mobileHub");

    if(!state.inputWord){
      setBadge(t("awaiting"));
      setStatus(t("enterAndExecute"));
      synthesisText.textContent = t("synthDefault");
    }
    refreshThemeToggleLabel();
  }

  // --------------------
  // Memory (saved runs)
  // --------------------
  function loadRuns(){
    try { return JSON.parse(localStorage.getItem(MEM_KEY)||"[]"); }
    catch { return []; }
  }
  function saveRuns(runs){
    localStorage.setItem(MEM_KEY, JSON.stringify(runs.slice(0,200)));
    renderAllNotes();
  }
  function addRun(run){
    const runs = loadRuns();
    const existingIdx = runs.findIndex(r => normalizeWord(r.word) === normalizeWord(run.word));
    if(existingIdx >= 0) runs.splice(existingIdx, 1);
    runs.unshift(run);
    saveRuns(runs);
  }

  // --------------------
  // Memory (saved cards)
  // --------------------
  function loadCards(){
    try { return JSON.parse(localStorage.getItem(MEM_CARDS_KEY)||"[]"); }
    catch { return []; }
  }
  function saveCards(cards){
    localStorage.setItem(MEM_CARDS_KEY, JSON.stringify(cards.slice(0,400)));
    renderAllNotes();
  }
  function addCard(card){
    const cards = loadCards();
    const existingIdx = cards.findIndex(c => normalizeWord(c.word) === normalizeWord(card.word));
    if(existingIdx >= 0) cards.splice(existingIdx, 1);
    cards.unshift(card);
    saveCards(cards);
  }

  function updateMemoryPill(){
    const runs = loadRuns();
    const cards = loadCards();
    memoryPill.textContent = `üß† Memory: ${runs.length} outputs ‚Ä¢ ${cards.length} cards`;
  }

  function getNotesFilter(){
    return normalizeWord(notesSearch?.value || "");
  }

  function renderSavedRuns(){
    const runs = loadRuns();
    const filter = getNotesFilter();
    const filtered = filter ? runs.filter(r => normalizeWord(r.word).includes(filter)) : runs;

    if(!runs.length){
      savedRunsEl.innerHTML = `<div class="muted" style="padding:8px 0;">No saved outputs yet.</div>`;
      return;
    }
    if(filter && !filtered.length){
      savedRunsEl.innerHTML = `<div class="muted" style="padding:8px 0;">No matching outputs.</div>`;
      return;
    }

    savedRunsEl.innerHTML = filtered.slice(0,60).map((r, idx) => `
      <div class="savedItem" data-type="run" data-load="${escapeHtml(r.word)}" data-created="${escapeHtml(r.createdAt)}">
        <div>
          <div class="savedWord">${escapeHtml(r.word)}</div>
          <div class="savedMeta muted">gen ${r.generation || 1} ‚Ä¢ ${new Date(r.createdAt).toLocaleString()}</div>
          ${r.langMode ? `<div class="savedMeta muted">mode: ${escapeHtml(r.langMode)}</div>` : ""}
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <div class="tag">Open</div>
          <div class="tag bad" data-delrun="${escapeHtml(r.createdAt)}" title="Delete this saved output">‚úï</div>
        </div>
      </div>
    `).join("");

    [...savedRunsEl.querySelectorAll("[data-load]")].forEach(el=>{
      el.addEventListener("click", ()=>{
        const w = el.getAttribute("data-load");
        mainSearch.value = w;
        executeStack();
        showView("feed-view");
      });
    });

    [...savedRunsEl.querySelectorAll("[data-delrun]")].forEach(el=>{
      el.addEventListener("click", (e)=>{
        e.stopPropagation();
        const createdAt = el.getAttribute("data-delrun");
        const runs = loadRuns().filter(r => r.createdAt !== createdAt);
        saveRuns(runs);
        setStatus(t("deletedOne"));
        setTimeout(()=>setStatus(""), 900);
      });
    });
  }

  function renderSavedCards(){
    const cards = loadCards();
    const filter = getNotesFilter();
    const filtered = filter ? cards.filter(c => normalizeWord(c.word).includes(filter) || normalizeWord(c.source || "").includes(filter)) : cards;

    if(!cards.length){
      savedCardsEl.innerHTML = `<div class="muted" style="padding:8px 0;">No saved cards yet.</div>`;
      return;
    }
    if(filter && !filtered.length){
      savedCardsEl.innerHTML = `<div class="muted" style="padding:8px 0;">No matching cards.</div>`;
      return;
    }

    savedCardsEl.innerHTML = filtered.slice(0,80).map((c) => `
      <div class="savedItem" data-type="card" data-cardword="${escapeHtml(c.word)}" data-created="${escapeHtml(c.createdAt)}">
        <div>
          <div class="savedWord">${escapeHtml((c.word||"").toUpperCase())}</div>
          <div class="savedMeta muted">from: ${escapeHtml((c.source||"").toUpperCase() || "‚Äî")} ‚Ä¢ ${new Date(c.createdAt).toLocaleString()}</div>
          <div class="savedMeta muted">score: ${Number(c.score||0).toFixed(2)} ‚Ä¢ mode: ${escapeHtml(c.langMode || "en")}</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <div class="tag">Open</div>
          <div class="tag bad" data-delcard="${escapeHtml(c.createdAt)}" title="Delete this saved card">‚úï</div>
        </div>
      </div>
    `).join("");

    [...savedCardsEl.querySelectorAll("[data-cardword]")].forEach(el=>{
      el.addEventListener("click", ()=>{
        const w = el.getAttribute("data-cardword");
        mainSearch.value = w;
        executeStack();
        showView("feed-view");
      });
    });

    [...savedCardsEl.querySelectorAll("[data-delcard]")].forEach(el=>{
      el.addEventListener("click", (e)=>{
        e.stopPropagation();
        const createdAt = el.getAttribute("data-delcard");
        const cards = loadCards().filter(c => c.createdAt !== createdAt);
        saveCards(cards);
        setStatus(t("deletedCard"));
        setTimeout(()=>setStatus(""), 900);
      });
    });
  }

  function renderAllNotes(){
    updateMemoryPill();
    renderSavedRuns();
    renderSavedCards();
  }

  notesSearch.addEventListener("input", ()=> renderAllNotes());

  clearSavedBtn.addEventListener("click", ()=>{
    localStorage.removeItem(MEM_KEY);
    renderAllNotes();
    setStatus(t("clearedSaved"));
    setTimeout(()=>setStatus(""), 1200);
  });

  clearSavedCardsBtn.addEventListener("click", ()=>{
    localStorage.removeItem(MEM_CARDS_KEY);
    renderAllNotes();
    setStatus(t("clearedCards"));
    setTimeout(()=>setStatus(""), 1200);
  });

  // --------------------
  // Emails (stored locally for now)
  // --------------------
  function loadEmails(){
    try { return JSON.parse(localStorage.getItem(MEM_EMAILS_KEY)||"[]"); }
    catch { return []; }
  }
  function saveEmail(email){
    const e = (email || "").trim().toLowerCase();
    if(!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)) return false;
    const list = loadEmails();
    if(!list.includes(e)) list.unshift(e);
    localStorage.setItem(MEM_EMAILS_KEY, JSON.stringify(list.slice(0,500)));
    return true;
  }
  emailSaveBtn.addEventListener("click", ()=>{
    const ok = saveEmail(emailInput.value);
    if(ok){
      emailSavedMsg.style.display = "block";
      setTimeout(()=> emailSavedMsg.style.display = "none", 2400);
      emailInput.value = "";
    }else{
      emailSavedMsg.style.display = "block";
      emailSavedMsg.textContent = "‚ùå Please enter a valid email.";
      setTimeout(()=>{
        emailSavedMsg.style.display = "none";
        emailSavedMsg.textContent = "‚úÖ Saved locally for now (we‚Äôll wire automation later).";
      }, 2200);
    }
  });

  // --------------------
  // Dictionary validation (SOFT)
  // --------------------
  const dictCache = new Map();

  async function dictCheck(word, lang){
    const w = normalizeWord(word);
    const key = `${lang}|${w}`;
    if(!w || w.length < 2) return { ok:false, uncertain:false };
    if(dictCache.has(key)) return dictCache.get(key);

    try{
      const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/${encodeURIComponent(lang)}/${encodeURIComponent(w)}`);
      const result = { ok: res.ok, uncertain: false };
      dictCache.set(key, result);
      return result;
    }catch(e){
      const result = { ok: true, uncertain: true };
      dictCache.set(key, result);
      return result;
    }
  }

  function languageBadgeFromVerdict(verdict){
    if(verdict.uncertain){
      setBadge(t("badgeNetworkSoft"), "bad");
      dictBadge.title = t("wordNotVerifiedTitle");
      return;
    }
    if(verdict.ok){
      setBadge(t("badgeDictOk"), "good");
      dictBadge.title = "";
      return;
    }
    setBadge(t("badgeDictSoftOk"), "bad");
    dictBadge.title = t("wordNotVerifiedTitle");
  }

  // --------------------
  // Link Packs (language-aware) + NEW ORDER + RHYME
  // --------------------
  function linkPackFor(lang, word){
    const w = word;
    const hl = (lang === "es") ? "es" : (lang === "de") ? "de" : "en";
    const gl = (lang === "es") ? "es" : (lang === "de") ? "de" : "us";

    // Rhyme destinations (simple, reliable):
    // - EN: RhymeZone direct query
    // - ES/DE: Google query in that language (works everywhere)
    const rhymeHref =
      (lang === "en")
        ? `https://www.rhymezone.com/r/rhyme.cgi?Word=${encodeURIComponent(w)}&typeofrhyme=perfect&org1=syl&org2=l&org3=y`
        : (lang === "es")
          ? `https://www.google.com/search?q=${encodeURIComponent("rimas de " + w)}&hl=es&gl=es`
          : `https://www.google.com/search?q=${encodeURIComponent("Reime " + w)}&hl=de&gl=de`;

    if(lang === "es"){
      return {
        dictLabel: "RAE",
        dictHref: `https://dle.rae.es/${encodeURIComponent(w)}`,
        wiktLabel: "Wikcionario",
        wiktHref: `https://es.wiktionary.org/wiki/${encodeURIComponent(w)}`,
        wikiLabel: "Wikipedia",
        wikiHref: `https://es.wikipedia.org/w/index.php?search=${encodeURIComponent(w)}`,
        encyLabel: "Encyclopedia",
        encyHref: `https://www.encyclopedia.com/gsearch?query=${encodeURIComponent(w)}`,
        thesLabel: "Sin√≥nimos",
        thesHref: `https://www.google.com/search?q=${encodeURIComponent("sin√≥nimos " + w)}&hl=es&gl=es`,
        ytHref: `https://www.youtube.com/results?search_query=${encodeURIComponent(w)}&hl=${hl}`,
        webHref: `https://www.google.com/search?q=${encodeURIComponent(w)}&hl=${hl}&gl=${gl}`,
        rhymeHref,
        rhymeLabel: "Rhyme"
      };
    }

    if(lang === "de"){
      return {
        dictLabel: "Duden",
        dictHref: `https://www.duden.de/suchen/dudenonline/${encodeURIComponent(w)}`,
        wiktLabel: "Wiktionary",
        wiktHref: `https://de.wiktionary.org/wiki/${encodeURIComponent(w)}`,
        wikiLabel: "Wikipedia",
        wikiHref: `https://de.wikipedia.org/w/index.php?search=${encodeURIComponent(w)}`,
        encyLabel: "Encyclopedia",
        encyHref: `https://www.encyclopedia.com/gsearch?query=${encodeURIComponent(w)}`,
        thesLabel: "Synonyme",
        thesHref: `https://www.openthesaurus.de/synonyme/${encodeURIComponent(w)}`,
        ytHref: `https://www.youtube.com/results?search_query=${encodeURIComponent(w)}&hl=${hl}`,
        webHref: `https://www.google.com/search?q=${encodeURIComponent(w)}&hl=${hl}&gl=${gl}`,
        rhymeHref,
        rhymeLabel: "Reim"
      };
    }

    return {
      dictLabel: "Dictionary.com",
      dictHref: `https://www.dictionary.com/browse/${encodeURIComponent(w)}`,
      wiktLabel: "Wiktionary (exact)",
      wiktHref: `https://en.wiktionary.org/wiki/${encodeURIComponent(w)}`,
      wikiLabel: "Wikipedia",
      wikiHref: `https://en.wikipedia.org/w/index.php?search=${encodeURIComponent(w)}`,
      encyLabel: "Encyclopedia",
      encyHref: `https://www.encyclopedia.com/gsearch?query=${encodeURIComponent(w)}`,
      thesLabel: "Thesaurus",
      thesHref: `https://www.thesaurus.com/browse/${encodeURIComponent(w)}`,
      ytHref: `https://www.youtube.com/results?search_query=${encodeURIComponent(w)}&hl=${hl}`,
      webHref: `https://www.google.com/search?q=${encodeURIComponent(w)}&hl=${hl}&gl=${gl}`,
      rhymeHref,
      rhymeLabel: "Rhyme"
    };
  }

  function buildLinksBlockHTML(lang, word){
    const pack = linkPackFor(lang, word);

    // Row 1 (priority): Web + Rhyme + YouTube
    // Row 2: Dictionary + Wikipedia + Wiktionary + Encyclopedia + Thesaurus
    return `
      <div class="tag-row" style="margin-top:10px;">
        <a class="tag brand-web"  rel="noopener noreferrer" target="_blank" href="${pack.webHref}">Web</a>
        <a class="tag brand-rhyme" rel="noopener noreferrer" target="_blank" href="${pack.rhymeHref}">${pack.rhymeLabel}</a>
        <a class="tag brand-yt"   rel="noopener noreferrer" target="_blank" href="${pack.ytHref}">YouTube</a>
      </div>
      <div class="tag-row" style="margin-top:10px;">
        <a class="tag brand-dict" rel="noopener noreferrer" target="_blank" href="${pack.dictHref}">${pack.dictLabel}</a>
        <a class="tag brand-wiki" rel="noopener noreferrer" target="_blank" href="${pack.wikiHref}">${pack.wikiLabel}</a>
        <a class="tag brand-wikt" rel="noopener noreferrer" target="_blank" href="${pack.wiktHref}">${pack.wiktLabel}</a>
        <a class="tag brand-ency" rel="noopener noreferrer" target="_blank" href="${pack.encyHref}">${pack.encyLabel}</a>
        <a class="tag brand-thes" rel="noopener noreferrer" target="_blank" href="${pack.thesHref}">${pack.thesLabel}</a>
      </div>
    `;
  }

  function renderMainWordLinks(){
    if(!state.inputWord){
      mainWordLinks.style.display = "none";
      mainWordLinks.innerHTML = "";
      return;
    }

    const pair = getCollabPair();
    const showToggle = !!pair;
    const lang = showToggle ? (state.mainLinkLang || pair.a) : state.mainLinkLang;

    mainWordLinks.style.display = "flex";

    const toggleBtn = showToggle
      ? `<button class="pill-btn" id="mainLinkToggle" title="Toggle main word link sources">${pair.labelA} ‚Üî ${pair.labelB} ‚Ä¢ ${lang.toUpperCase()}</button>`
      : "";

    mainWordLinks.innerHTML = `
      ${toggleBtn}
      <div style="width:100%; max-width: 860px;">
        ${buildLinksBlockHTML(lang, normalizeWord(state.inputWord))}
      </div>
    `;

    const btn = $("mainLinkToggle");
    if(btn){
      btn.addEventListener("click", ()=>{
        const p = getCollabPair();
        if(!p) return;
        state.mainLinkLang = (state.mainLinkLang === p.a) ? p.b : p.a;
        renderMainWordLinks();
      });
    }
  }

  // --------------------
  // Datamuse expansions
  // --------------------
  async function dm(params){
    const url = `https://api.datamuse.com/words?${params}`;
    const res = await fetch(url);
    if(!res.ok) return [];
    return res.json();
  }

  function layerReasons(){
    return [
      { layer:"Apophenia", type:"mix", reason:(seed, w)=>`Apophenia: loose association from "${seed}" toward "${w}".` },
      { layer:"Phonosemantic", type:"sl",  reason:(seed, w)=>`Phonosemantic: pronunciation / syllable sound from "${seed}" toward "${w}".` },
      { layer:"Phonetic Drift", type:"sl", reason:(seed, w)=>`Phonetic drift: sound-slide from "${seed}" toward "${w}".` },
      { layer:"Semiotic", type:"sp",       reason:(seed, w)=>`Semiotic: glyph/shape pattern from "${seed}" toward "${w}".` },
      { layer:"Morphological", type:"sp",  reason:(seed, w)=>`Morphological: structural reanalysis from "${seed}" toward "${w}".` },
      { layer:"Metaphorical", type:"ml",   reason:(seed, w)=>`Metaphorical: meaning adjacency from "${seed}" toward "${w}".` },
      { layer:"Symbolic", type:"ml",       reason:(seed, w)=>`Symbolic: archetypal association from "${seed}" toward "${w}".` },
      { layer:"Associative", type:"ml",    reason:(seed, w)=>`Associative: spreading activation from "${seed}" toward "${w}".` },
      { layer:"Predictive", type:"ml",     reason:(seed, w)=>`Predictive: narrative completion from "${seed}" toward "${w}".` },
    ];
  }

  function buildSeeds(word){
    const w = normalizeWord(word);
    const seeds = new Set();
    seeds.add(w);

    for(let i=0;i<w.length;i++){
      for(let j=i+3;j<=w.length;j++){
        seeds.add(w.slice(i,j));
      }
    }

    seeds.add(w.replace(/ph/g,"f"));
    seeds.add(w.replace(/c(?=[eiy])/g,"s"));
    seeds.add(w.replace(/tion/g,"shun"));
    seeds.add(w.replace(/[aeiou√°√©√≠√≥√∫√º]/g,""));

    seeds.add(w.split("").reverse().join(""));
    seeds.add(w.replace(/w/g,"uu"));
    seeds.add(w.replace(/m/g,"nn"));

    const arr = [...seeds].filter(s=>s && s.length >= 2);
    arr.sort((a,b)=>b.length-a.length);
    return arr.slice(0, 18);
  }

  function score(word, meta){
    const w = normalizeWord(word);
    let s = 0;

    const layerCount = meta.layers.size;
    s += Math.min(0.35, (layerCount-1) * 0.10);

    if(meta.types.has("sl")) s += 0.12;
    if(meta.types.has("ml")) s += 0.10;
    if(meta.types.has("sp")) s += 0.08;

    const vowel = (w.match(/[aeiou√°√©√≠√≥√∫√º]/g)||[]).length;
    s += Math.min(0.18, vowel * 0.03);

    if(w.length >= 4 && w.length <= 9) s += 0.12;
    if(w.length <= 3) s -= 0.10;

    if(state.used.has(w)) s -= 0.30;

    return Math.max(0, Math.min(1, s));
  }

  function mergeCandidate(word, layer, type, reason, seed){
    const w = normalizeWord(word);
    const s = normalizeWord(seed);
    if(!w) return;
    if(w === normalizeWord(state.inputWord)) return;

    if(!state.poolMeta.has(w)){
      state.poolMeta.set(w, {
        word: w,
        layers: new Set([layer]),
        types: new Set([type]),
        reasons: new Set([reason]),
        seedByType: new Map(s ? [[type, s]] : []),
      });
    } else {
      const m = state.poolMeta.get(w);
      m.layers.add(layer);
      m.types.add(type);
      m.reasons.add(reason);
      if(s && !m.seedByType.has(type)) m.seedByType.set(type, s);
    }
  }

  function datamuseParamsForLayer(L, cleanSeed, vocab){
    const v = (vocab === "es") ? "&v=es" : (vocab === "enwiki") ? "&v=enwiki" : "";
    if(L.type === "sl"){
      return `sl=${encodeURIComponent(cleanSeed)}&max=18${v}`;
    } else if(L.type === "ml"){
      return `ml=${encodeURIComponent(cleanSeed)}&max=18${v}`;
    } else if(L.type === "sp"){
      const pattern = cleanSeed.length >= 4 ? `*${cleanSeed}*` : `${cleanSeed}*`;
      return `sp=${encodeURIComponent(pattern)}&max=18${v}`;
    }
    return null;
  }

  async function queryLayer(L, cleanSeed, vocab){
    try{
      const v = (vocab === "es") ? "&v=es" : (vocab === "enwiki") ? "&v=enwiki" : "";
      if(L.type === "mix"){
        const a = await dm(`sl=${encodeURIComponent(cleanSeed)}&max=10${v}`);
        const b = await dm(`ml=${encodeURIComponent(cleanSeed)}&max=10${v}`);
        const c = await dm(`sp=${encodeURIComponent("*"+cleanSeed+"*")}&max=10${v}`);
        return [...a,...b,...c];
      }
      const params = datamuseParamsForLayer(L, cleanSeed, vocab);
      if(!params) return [];
      return await dm(params);
    }catch(e){
      return [];
    }
  }

  function getVocabPlan(){
    const mode = getLangMode();
    if(mode === "es") return ["es"];
    if(mode === "mix") return ["en","es"];
    if(mode === "de") return ["enwiki"];
    if(mode === "en_de") return ["en","enwiki"];
    return ["en"];
  }

  async function runOneGeneration(seedWords){
    const layers = layerReasons();
    const seeds = [];
    for(const sw of seedWords){
      buildSeeds(sw).forEach(s => seeds.push(s));
    }

    const vocabs = getVocabPlan();

    for(const L of layers){
      const seed = seeds[(state.seedCursor++) % seeds.length] || normalizeWord(state.inputWord);
      const cleanSeed = normalizeWord(seed);
      if(!cleanSeed || cleanSeed.length < 2) continue;

      for(const vocab of vocabs){
        const results = await queryLayer(L, cleanSeed, vocab);
        for(const r of results){
          const cand = normalizeWord(r.word);
          if(!cand || cand.length < 3) continue;
          mergeCandidate(cand, L.layer, L.type, L.reason(cleanSeed, cand), cleanSeed);
        }
      }
    }

    const all = [...state.poolMeta.values()].map(m => ({
      word: m.word,
      layers: m.layers,
      types: m.types,
      reasons: [...m.reasons],
      seedByType: m.seedByType,
      score: score(m.word, m),
      isNew: !state.used.has(m.word)
    }));

    all.sort((a,b)=> (b.score - a.score) || (b.layers.size - a.layers.size) || a.word.localeCompare(b.word));

    const batch = [];
    for(const item of all){
      if(batch.length >= PAGE_SIZE) break;
      if(state.used.has(item.word)) continue;
      batch.push(item);
      state.used.add(item.word);
    }

    const novelty = batch.length ? batch.filter(x=>x.isNew).length / batch.length : 0;
    return { batch, novelty };
  }

  function bestReason(item){
    const pref = item.reasons.find(r =>
      r.toLowerCase().includes("phonetic drift") ||
      r.toLowerCase().includes("phonosemantic") ||
      r.toLowerCase().includes("pronunciation")
    );
    return pref || item.reasons[0] || "Pattern derived.";
  }

  function anchorLine(item){
    const seedSound = item.seedByType?.get("sl");
    if(!seedSound) return "";
    return `
      <div class="tag-row" style="margin-top:10px;">
        <span class="tag bad" title="This token may be a drift midpoint rather than a strict dictionary headword.">
          Not in dictionary ‚Äî anchored to ${escapeHtml(seedSound.toUpperCase())}
        </span>
      </div>
    `;
  }

  // --------------------
  // Lens (Pattern meaning)
  // --------------------
  const PATTERN_GLOSS = {
    "Apophenia": {
      meaning: "Seeing a loose connection or relationship between ideas that aren‚Äôt strictly related.",
      example: (seed, w) => `"${seed}" ‚Üí (loose association) ‚Üí "${w}"`
    },
    "Phonosemantic": {
      meaning: "A connection driven by pronunciation or syllable feel ‚Äî the sound suggests a neighbor word.",
      example: (seed, w) => `"${seed}" ‚Üí (sound feel) ‚Üí "${w}"`
    },
    "Phonetic Drift": {
      meaning: "A sound-slide: small phoneme shifts (vowels/consonants/syllables) nudge one form toward another.",
      example: (seed, w) => `"${seed}" ‚Üí (sound-slide) ‚Üí "${w}"`
    },
    "Semiotic": {
      meaning: "A connection based on symbol/shape/glyph patterns ‚Äî how the word looks or its visual structure.",
      example: (seed, w) => `"${seed}" ‚Üí (visual pattern) ‚Üí "${w}"`
    },
    "Morphological": {
      meaning: "A connection based on word structure ‚Äî roots, affixes, stems, or structural reanalysis.",
      example: (seed, w) => `"${seed}" ‚Üí (structure shift) ‚Üí "${w}"`
    },
    "Metaphorical": {
      meaning: "A meaning leap through metaphor ‚Äî adjacent ideas, imagery, or conceptual neighbors.",
      example: (seed, w) => `"${seed}" ‚Üí (metaphor) ‚Üí "${w}"`
    },
    "Symbolic": {
      meaning: "A connection through archetypes or symbols ‚Äî cultural or thematic resonance.",
      example: (seed, w) => `"${seed}" ‚Üí (symbol) ‚Üí "${w}"`
    },
    "Associative": {
      meaning: "Spreading activation: activating one concept primes related concepts in memory networks.",
      example: (seed, w) => `"${seed}" primes neighbors ‚Üí "${w}"`
    },
    "Predictive": {
      meaning: "A narrative completion move ‚Äî the engine guesses a plausible continuation from the seed context.",
      example: (seed, w) => `"${seed}" ‚Üí (completion) ‚Üí "${w}"`
    }
  };

  function extractPatternName(reasonLine){
    const raw = (reasonLine || "").split(":")[0].trim();
    return raw
      .split(" ")
      .map(x => x ? (x[0].toUpperCase() + x.slice(1).toLowerCase()) : x)
      .join(" ");
  }

  function extractSeed(reasonLine){
    const m = (reasonLine || "").match(/from\s+"([^"]+)"/i);
    return m ? m[1] : state.inputWord;
  }

  // --------------------
  // Card render
  // --------------------
  function buildCard(item){
    const div = document.createElement("div");
    div.className = "card";
    div.style.borderLeft = "3px solid var(--accent)";
    div.id = "scorecard";

    const pair = getCollabPair();
    const showToggle = !!pair;
    const linkLang = showToggle ? (state.cardLinkLang || pair.a) : state.cardLinkLang;

    const reasonLine = bestReason(item);
    const patternName = extractPatternName(reasonLine);
    const seed = extractSeed(reasonLine);
    const gloss = PATTERN_GLOSS[patternName];

    const lensBtnLabel = state.lensOpen ? "‚ìò Hide Pattern Meaning" : "‚ìò Pattern Meaning";

    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;">
        <div style="font-weight:1000; letter-spacing:1px;">
          PATTERN: <span class="mono">${escapeHtml(item.word.toUpperCase())}</span>
        </div>

        <div style="display:flex; align-items:center; gap:10px; flex-wrap:wrap; justify-content:flex-end;">
          ${showToggle ? `
            <button class="pill-btn" data-toggle-linklang title="Toggle scorecard link sources">
              ${pair.labelA} ‚Üî ${pair.labelB} ‚Ä¢ ${linkLang.toUpperCase()}
            </button>
          ` : ""}

          <button class="pill-btn" data-save-card title="Save this scorecard">
            üíæ Save Card
          </button>

          <div class="muted" style="font-size:0.8rem; font-weight:900;">
            SCORE: ${item.score.toFixed(2)}
          </div>
        </div>
      </div>

      <p class="muted" style="margin:10px 0 0; font-size:0.98rem; line-height:1.5;">
        ${escapeHtml(reasonLine)}
      </p>

      <div class="tag-row" style="margin-top:10px;">
        <span class="tag brand-lens" data-toggle-lens>${lensBtnLabel}</span>
      </div>

      ${state.lensOpen && gloss ? `
        <div class="lensBox">
          <div class="muted" style="font-size:0.78rem; letter-spacing:2px; text-transform:uppercase; margin-bottom:6px;">Lens</div>
          <div style="font-weight:900; letter-spacing:0.6px;">${escapeHtml(patternName)}</div>
          <div class="muted" style="margin-top:6px; line-height:1.55;">
            ${escapeHtml(gloss.meaning)}
          </div>
          <div class="muted" style="margin-top:8px;">
            <span style="opacity:0.9;">Example:</span> ${escapeHtml(gloss.example(seed, item.word))}
          </div>
        </div>
      ` : ""}

      ${anchorLine(item)}

      ${buildLinksBlockHTML(linkLang || "en", item.word)}
    `;

    const toggleLangBtn = div.querySelector("[data-toggle-linklang]");
    if(toggleLangBtn){
      toggleLangBtn.addEventListener("click", ()=>{
        const p = getCollabPair();
        if(!p) return;
        state.cardLinkLang = (state.cardLinkLang === p.a) ? p.b : p.a;
        openSingleCard(item, { keepScroll:true });
      });
    }

    const lensBtn = div.querySelector("[data-toggle-lens]");
    if(lensBtn){
      lensBtn.addEventListener("click", ()=>{
        state.lensOpen = !state.lensOpen;
        openSingleCard(item, { keepScroll:true });
      });
    }

    const saveCardBtn = div.querySelector("[data-save-card]");
    if(saveCardBtn){
      saveCardBtn.addEventListener("click", ()=>{
        addCard({
          word: item.word,
          createdAt: new Date().toISOString(),
          source: state.inputWord || "",
          score: item.score,
          reason: reasonLine,
          langMode: getLangMode(),
          linkLang: (linkLang || "en")
        });
        setStatus(t("savedCard"));
        setTimeout(()=>{
          if(state.allResults.length){
            setStatus(`Generated ${state.allResults.length} words ‚Ä¢ gen ${state.generation}`);
          }
        }, 900);
      });
    }

    return div;
  }

  function openSingleCard(item, opts = {}){
    state.activeCardItem = item;

    const mode = getLangMode();
    const pair = getCollabPair();
    if(pair){
      if(!state.cardLinkLang) state.cardLinkLang = pair.a;
    } else {
      state.cardLinkLang = (mode === "es") ? "es" : (mode === "de") ? "de" : "en";
    }

    cardsArea.innerHTML = "";
    cardsArea.appendChild(buildCard(item));
    synthesisText.textContent = `"${item.word}" ‚Ä¢ ${bestReason(item)}`;

    if(!opts.keepScroll){
      scrollToScorecard();
    }
  }

  function scrollToScorecard(){
    const card = document.getElementById("scorecard");
    if(!card) return;
    requestAnimationFrame(() => {
      card.scrollIntoView({ behavior: "smooth", block: "start" });
    });
  }

  function renderWordButtons(batch){
    wordListEl.innerHTML = "";
    batch.forEach(item=>{
      const btn = document.createElement("button");
      btn.className = "wordBtn";
      btn.textContent = item.word;
      btn.title = "Click to open";
      btn.addEventListener("click", ()=> {
        state.lensOpen = false;
        openSingleCard(item);
      });
      wordListEl.appendChild(btn);
    });
  }

  // --------------------
  // Execute / More / Clear
  // --------------------
  function setRestrictedUI(on){
    state.restricted = on;
    restrictedBlock.style.display = on ? "block" : "none";
    if(!on){
      emailSavedMsg.style.display = "none";
      emailInput.value = "";
    }
  }

  async function executeStack(){
    if(state.running) return;
    const raw = mainSearch.value.trim();
    if(!raw) return;

    state.running = true;
    executeBtn.disabled = true;
    moreBtn.disabled = true;
    saveBtn.disabled = true;

    setRestrictedUI(false);

    setBadge(t("checkingDict"));
    setStatus(t("validating"));

    // Restrict generation on input categories (simple phase)
    if(isRestrictedInput(raw)){
      // UI only: show block + email capture
      state.inputWord = raw;
      displayWord.textContent = raw.toUpperCase();
      mainWordLinks.style.display = "none";
      mainWordLinks.innerHTML = "";

      wordListEl.innerHTML = "";
      cardsArea.innerHTML = "";

      setBadge("Restricted", "bad");
      setStatus("This term cannot be produced at this time.");
      synthesisText.textContent = t("synthDefault");

      setRestrictedUI(true);

      state.running = false;
      executeBtn.disabled = false;
      moreBtn.disabled = true;
      saveBtn.disabled = true;
      return;
    }

    const mode = getLangMode();
    let verdict = { ok:false, uncertain:false };

    if(mode === "mix"){
      const v1 = await dictCheck(raw, "en");
      const v2 = await dictCheck(raw, "es");
      verdict.uncertain = v1.uncertain || v2.uncertain;
      verdict.ok = v1.ok || v2.ok || verdict.uncertain;
    } else if(mode === "en_de"){
      const v1 = await dictCheck(raw, "en");
      const v2 = await dictCheck(raw, "de");
      verdict.uncertain = v1.uncertain || v2.uncertain;
      verdict.ok = v1.ok || v2.ok || verdict.uncertain;
    } else if(mode === "es"){
      verdict = await dictCheck(raw, "es");
    } else if(mode === "de"){
      verdict = await dictCheck(raw, "de");
    } else {
      verdict = await dictCheck(raw, "en");
    }

    languageBadgeFromVerdict(verdict);

    // reset run
    state.inputWord = raw;
    state.generation = 1;
    state.used = new Set();
    state.lastBatch = [];
    state.allResults = [];
    state.poolMeta = new Map();
    state.seedCursor = 0;
    state.activeCardItem = null;
    state.lensOpen = false;

    // reset toggles
    const pair = getCollabPair();
    if(pair){
      state.cardLinkLang = pair.a;
      state.mainLinkLang = pair.a;
    } else {
      state.cardLinkLang = (mode === "es") ? "es" : (mode === "de") ? "de" : "en";
      state.mainLinkLang = state.cardLinkLang;
    }

    displayWord.textContent = raw.toUpperCase();
    renderMainWordLinks();

    // Running animation ON
    setStatus(t("runningStack"));
    setLoading(true);

    let { batch, novelty } = await runOneGeneration([raw]);

    // Output hard filter (no unacceptable drift)
    batch = filterHardBlocked(batch);

    state.lastBatch = batch;
    state.allResults = [...batch];

    renderWordButtons(batch);

    cardsArea.innerHTML = "";
    synthesisText.textContent = t("readyTap", raw.toUpperCase());

    // Running animation OFF
    setLoading(false);

    setStatus(`Generated ${batch.length} words ‚Ä¢ gen ${state.generation} ‚Ä¢ novelty ${novelty.toFixed(2)}`);

    moreBtn.disabled = false;
    saveBtn.disabled = false;
    state.running = false;
    executeBtn.disabled = false;
  }

  async function generateMore(){
    if(state.running) return;
    if(!state.lastBatch.length) return;

    state.running = true;
    moreBtn.disabled = true;

    const seedWords = state.lastBatch.slice(0, 10).map(x=>x.word);

    setStatus(t("expanding"));
    setLoading(true);

    state.generation += 1;
    let { batch, novelty } = await runOneGeneration(seedWords);

    batch = filterHardBlocked(batch);

    if(!batch.length || novelty < NOVELTY_MIN){
      setLoading(false);
      setStatus(t("stopPoint"));
      moreBtn.disabled = true;
      state.running = false;
      return;
    }

    state.lastBatch = batch;
    state.allResults = [...state.allResults, ...batch];
    renderWordButtons(batch);

    cardsArea.innerHTML = "";
    synthesisText.textContent = t("expandedTap", state.inputWord.toUpperCase());

    setLoading(false);
    setStatus(`Generated ${batch.length} words ‚Ä¢ gen ${state.generation} ‚Ä¢ novelty ${novelty.toFixed(2)}`);

    moreBtn.disabled = false;
    state.running = false;
  }

  function clearOutput(){
    state.inputWord = "";
    state.generation = 0;
    state.used = new Set();
    state.lastBatch = [];
    state.allResults = [];
    state.poolMeta = new Map();
    state.seedCursor = 0;
    state.activeCardItem = null;
    state.lensOpen = false;

    displayWord.textContent = "‚Äî";
    wordListEl.innerHTML = "";
    cardsArea.innerHTML = "";
    synthesisText.textContent = t("synthDefault");

    mainWordLinks.style.display = "none";
    mainWordLinks.innerHTML = "";

    setRestrictedUI(false);

    setBadge(t("awaiting"));
    setStatus(t("cleared"));
    setLoading(false);

    moreBtn.disabled = true;
    saveBtn.disabled = true;

    mainSearch.value = "";
    mainSearch.focus();
  }

  function saveCurrent(){
    if(!state.inputWord || !state.allResults.length) return;

    addRun({
      word: state.inputWord.toUpperCase(),
      createdAt: new Date().toISOString(),
      generation: state.generation,
      langMode: getLangMode(),
      results: state.allResults.map(x=>({
        word: x.word,
        reasons: x.reasons.slice(0,2),
        score: x.score,
        anchor: x.seedByType?.get("sl") || ""
      }))
    });

    setStatus(t("saved"));
    setTimeout(()=>setStatus(`Generated ${state.allResults.length} words ‚Ä¢ gen ${state.generation}`), 1200);
  }

  executeBtn.addEventListener("click", executeStack);
  moreBtn.addEventListener("click", generateMore);
  clearBtn.addEventListener("click", clearOutput);
  saveBtn.addEventListener("click", saveCurrent);

  mainSearch.addEventListener("keydown", (e)=>{
    if(e.key === "Enter") executeStack();
  });

  // --------------------
  // Mobile view switcher
  // --------------------
  function showView(id) {
    const views = ['notes-view', 'feed-view'];
    views.forEach(v => {
      const el = document.getElementById(v);
      if (window.innerWidth <= 1024) {
        el.style.display = (v === id) ? 'block' : 'none';
      }
    });
  }
  window.showView = showView;

  window.addEventListener('resize', () => {
    if (window.innerWidth > 1024) {
      ['notes-view', 'feed-view'].forEach(id => {
        document.getElementById(id).style.display = 'block';
      });
    }
  });

  // --------------------
  // Boot
  // --------------------
  (function boot(){
    setTheme(getTheme());
    const savedLang = localStorage.getItem(LANG_KEY) || "en";
    langSelect.value = savedLang;

    applyUiText();
    renderAllNotes();
    clearOutput();
  })();
</script>
</body>
</html>
