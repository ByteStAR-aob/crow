<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>World Words Hub ‚Äî Pattern Stacking Engine.</title>
  <style>
    :root {
      --bg: #070b14;
      --panel: #0f172a;
      --accent: #7c3aed;
      --accent-glow: rgba(124, 58, 237, 0.3);
      --text-main: #e2e8f0;
      --text-muted: #94a3b8;
      --border: rgba(255, 255, 255, 0.05);
      --glass: rgba(15, 23, 42, 0.6);
      --danger:#ff6b6b;
      --good:#22c55e;
    }

    * { box-sizing: border-box; font-family: 'Inter', system-ui, -apple-system, sans-serif; }
    body {
      margin: 0;
      background-color: var(--bg);
      color: var(--text-main);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    header {
      padding: 1rem 1.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 1px solid var(--border);
      background: var(--panel);
      z-index: 10;
      gap: 12px;
    }

    .memory-pill {
      background: rgba(124, 58, 237, 0.1);
      border: 1px solid var(--accent);
      padding: 4px 12px;
      border-radius: 999px;
      font-size: 0.82rem;
      color: var(--accent);
      font-weight: 700;
      white-space: nowrap;
    }

    .dashboard {
      display: grid;
      grid-template-columns: 300px 1fr;
      flex: 1;
      overflow: hidden;
    }

    section {
      padding: 1.5rem;
      overflow-y: auto;
      border-right: 1px solid var(--border);
      scrollbar-width: thin;
      scrollbar-color: var(--accent) var(--bg);
    }
    #feed-view { border-right: none; }

    h2 {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      color: var(--text-muted);
      margin: 0 0 1rem;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 1.2rem;
      margin-bottom: 1rem;
      transition: 0.2s;
    }
    .card:hover { border-color: rgba(124,58,237,0.45); }

    .muted{ color: var(--text-muted); }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }

    .tag-row { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }
    .tag {
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid var(--border);
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 0.75rem;
      color: var(--text-muted);
      text-decoration: none;
      user-select: none;
      cursor: pointer;
      display:inline-block;
      transition: 0.15s;
    }
    .tag:hover { background: rgba(124, 58, 237, 0.15); color: white; }
    .tag.good { border-color: rgba(34,197,94,0.35); color: rgba(34,197,94,0.95); }
    .tag.bad  { border-color: rgba(255,107,107,0.35); color: rgba(255,107,107,0.95); }

    /* Brand tints (subtle) */
    .tag.brand-yt   { border-color: rgba(255,0,0,0.35);     color: rgba(255,110,110,0.95); }
    .tag.brand-wiki { border-color: rgba(180,180,180,0.35); color: rgba(225,225,225,0.95); }
    .tag.brand-wikt { border-color: rgba(90,160,255,0.35);  color: rgba(170,210,255,0.95); }
    .tag.brand-dict { border-color: rgba(124,58,237,0.55);  color: rgba(205,175,255,0.95); }
    .tag.brand-web  { border-color: rgba(34,197,94,0.35);   color: rgba(34,197,94,0.95); }

    .search-container {
      display: flex;
      justify-content: center;
      margin-bottom: 1rem;
    }
    .search-wrapper {
      display: flex;
      align-items: center;
      background: var(--glass);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 6px 6px 18px;
      width: 100%;
      max-width: 720px;
      transition: 0.3s;
      backdrop-filter: blur(10px);
      gap: 10px;
    }
    .search-wrapper:focus-within {
      border-color: var(--accent);
      box-shadow: 0 0 20px var(--accent-glow);
    }
    #mainSearch {
      background: transparent;
      border: none;
      color: white;
      font-size: 1rem;
      flex: 1;
      outline: none;
      min-width: 120px;
    }

    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 9px 16px;
      border-radius: 999px;
      cursor: pointer;
      font-weight: 900;
      text-transform: uppercase;
      font-size: 0.72rem;
      letter-spacing: 1px;
      white-space: nowrap;
    }
    .btn.secondary {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-main);
      font-weight: 800;
    }
    .btn:disabled{
      opacity:0.55;
      cursor:not-allowed;
    }

    footer {
      padding: 0.8rem;
      text-align: center;
      font-size: 0.75rem;
      color: var(--text-muted);
      border-top: 1px solid var(--border);
      background: var(--bg);
    }

    .mobile-nav {
      display: none;
      background: var(--panel);
      padding: 10px;
      border-top: 1px solid var(--border);
      justify-content: space-around;
      gap: 8px;
    }

    @media (max-width: 1024px) {
      .dashboard { grid-template-columns: 1fr; }
      .side-panel { display: none; }
      .active-view { display: block !important; }
      .mobile-nav { display: flex; }
      section { border-right: none; }
    }

    /* Hub output */
    .wordHero{
      text-align:center;
      margin-bottom: 1rem;
    }
    .wordHero h1{
      font-size: 3.0rem;
      margin:0;
      letter-spacing: 8px;
      font-weight: 900;
      filter: drop-shadow(0 0 10px var(--accent-glow));
    }

    .wordListGrid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap: 10px;
      margin-top: 10px;
    }
    @media (min-width: 900px){
      .wordListGrid{ grid-template-columns: repeat(4, minmax(0,1fr)); }
    }
    .wordBtn{
      width:100%;
      text-align:left;
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--border);
      color: var(--text-main);
      padding: 10px 12px;
      border-radius: 12px;
      cursor:pointer;
      transition: 0.15s;
      font-weight: 900;
      letter-spacing: 0.3px;
    }
    .wordBtn:hover{ border-color: rgba(124,58,237,0.55); transform: translateY(-1px); }

    .divider{
      margin: 18px 0;
      height: 1px;
      background: var(--border);
    }

    /* Notes list items */
    .savedItem{
      padding: 12px 4px;
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 12px;
    }
    .savedItem:hover{ background: rgba(255,255,255,0.02); border-radius: 10px; padding-left: 10px; padding-right: 10px; }
    .savedWord{ font-weight: 1000; letter-spacing: 1px; }
    .savedMeta{ font-size: 0.8rem; opacity: 0.65; }
  </style>
</head>

<body>
<header>
  <div>
    <h1 style="font-size: 1.05rem; margin: 0; letter-spacing: 1px;">WORLD WORDS HUB</h1>
    <p style="font-size: 0.65rem; margin: 2px 0 0; color: var(--text-muted);">Decode Language. Find Patterns.
</p>
  </div>
  <div class="memory-pill" id="memoryPill">üß† Memory: 0 saved</div>
</header>

<main class="dashboard">
  <!-- NOTES -->
  <section id="notes-view" class="side-panel">
    <h2>Saved Outputs</h2>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div class="muted" style="font-size:0.9rem;">
          Tap a saved word to load it in the Hub.
        </div>
        <button class="btn secondary" id="clearSaved">Clear Saved</button>
      </div>

      <div id="savedRuns" style="margin-top: 12px;"></div>
    </div>
  </section>

  <!-- HUB -->
  <section id="feed-view" class="active-view">
    <div class="search-container">
      <div class="search-wrapper">
        <input type="text" id="mainSearch" placeholder="Type a real dictionary word‚Ä¶" autocomplete="off" />
        <button class="btn" id="executeBtn">Execute</button>
        <button class="btn secondary" id="clearBtn">Clear</button>
      </div>
    </div>

    <div class="wordHero">
      <p class="muted" style="margin:0; letter-spacing:2px; text-transform:uppercase; font-size:0.8rem; color: var(--accent);">
        Results for:
      </p>
      <h1 id="displayWord">‚Äî</h1>
      <p id="statusLine" class="muted" style="margin:10px 0 0;">Enter a word and press Execute.</p>

      <div style="display:flex; gap:10px; justify-content:center; margin-top:14px; flex-wrap:wrap;">
        <button class="btn secondary" id="moreBtn" disabled>Generate More</button>
        <button class="btn secondary" id="saveBtn" disabled>Save Output</button>
      </div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; flex-wrap:wrap;">
        <div>
          <div class="muted" style="font-size:0.8rem; letter-spacing:2px; text-transform:uppercase;">Generated Words</div>
          <div class="muted" style="font-size:0.85rem;">Click one word ‚Äî it will show ONE card below.</div>
        </div>
        <div id="dictBadge" class="tag">Awaiting input‚Ä¶</div>
      </div>

      <div id="wordList" class="wordListGrid" style="margin-top:14px;"></div>

      <div class="divider"></div>

      <!-- SINGLE SELECTED CARD AREA -->
      <div id="cardsArea" style="margin-top:12px;"></div>
    </div>

    <div style="margin-top: 1.2rem; opacity: 0.95;">
      <h2>Synthesis</h2>
      <div class="card" style="background: linear-gradient(135deg, rgba(124, 58, 237, 0.1), transparent);">
        <p id="synthesisText" style="line-height: 1.6; font-style: italic; margin:0;">
          "The engine identifies patterns. The human determines truth."
        </p>
      </div>
    </div>
  </section>
</main>

<nav class="mobile-nav">
  <button class="btn" style="padding:8px 15px;" onclick="showView('notes-view')">Notes</button>
  <button class="btn" style="padding:8px 15px;" onclick="showView('feed-view')">Hub</button>
</nav>

<footer>
  ¬© 2026 World Words Hub ‚Ä¢ Powered by CROW Lens.  
  <a href="https://www.bluecomet.work" target="_blank" rel="noopener noreferrer">üåê</a>
  A word is not just a word ‚Äî it‚Äôs a container of patterns, sounds, and meanings.
</footer>


<script>
  const $ = (id)=>document.getElementById(id);

  const mainSearch = $("mainSearch");
  const executeBtn = $("executeBtn");
  const clearBtn   = $("clearBtn");
  const moreBtn    = $("moreBtn");
  const saveBtn    = $("saveBtn");

  const displayWord = $("displayWord");
  const statusLine  = $("statusLine");
  const synthesisText = $("synthesisText");

  const wordListEl  = $("wordList");
  const cardsArea   = $("cardsArea");
  const dictBadge   = $("dictBadge");

  const savedRunsEl = $("savedRuns");
  const clearSavedBtn = $("clearSaved");
  const memoryPill  = $("memoryPill");

  const PAGE_SIZE = 20;
  const NOVELTY_MIN = 0.20;

  const MEM_KEY = "wwh_saved_runs_v1";

  let state = {
    inputWord: "",
    generation: 0,
    used: new Set(),
    lastBatch: [],
    poolMeta: new Map(),
    seedCursor: 0,
    running: false,
  };

  function normalizeWord(s){
    return (s||"").toLowerCase().trim().normalize("NFKD").replace(/[^a-z'-]/g,"");
  }

  function escapeHtml(s){
    return (s||"").replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
    }[m]));
  }

  function setStatus(msg){ statusLine.textContent = msg; }
  function setBadge(text, cls){
    dictBadge.className = "tag" + (cls ? " " + cls : "");
    dictBadge.textContent = text;
  }

  // --------------------
  // Memory (saved runs)
  // --------------------
  function loadRuns(){
    try { return JSON.parse(localStorage.getItem(MEM_KEY)||"[]"); }
    catch { return []; }
  }
  function saveRuns(runs){
    localStorage.setItem(MEM_KEY, JSON.stringify(runs.slice(0,200)));
    renderSavedRuns();
  }
  function addRun(run){
    const runs = loadRuns();
    const existingIdx = runs.findIndex(r => normalizeWord(r.word) === normalizeWord(run.word));
    if(existingIdx >= 0) runs.splice(existingIdx, 1);
    runs.unshift(run);
    saveRuns(runs);
  }

  function renderSavedRuns(){
    const runs = loadRuns();
    memoryPill.textContent = `üß† Memory: ${runs.length} saved`;

    if(!runs.length){
      savedRunsEl.innerHTML = `<div class="muted" style="padding:8px 0;">No saved outputs yet.</div>`;
      return;
    }

    savedRunsEl.innerHTML = runs.slice(0,50).map((r, idx) => `
      <div class="savedItem" data-load="${escapeHtml(r.word)}" data-idx="${idx}">
        <div>
          <div class="savedWord">${escapeHtml(r.word)}</div>
          <div class="savedMeta muted">gen ${r.generation || 1} ‚Ä¢ ${new Date(r.createdAt).toLocaleString()}</div>
        </div>
        <div style="display:flex; gap:8px; align-items:center;">
          <div class="tag">Open</div>
          <div class="tag bad" data-del="${idx}" title="Delete this saved item">‚úï</div>
        </div>
      </div>
    `).join("");

    // open saved
    [...savedRunsEl.querySelectorAll("[data-load]")].forEach(el=>{
      el.addEventListener("click", ()=>{
        const w = el.getAttribute("data-load");
        mainSearch.value = w;
        executeStack();
        showView("feed-view");
      });
    });

    // delete one
    [...savedRunsEl.querySelectorAll("[data-del]")].forEach(el=>{
      el.addEventListener("click", (e)=>{
        e.stopPropagation();
        const idx = Number(el.getAttribute("data-del"));
        const runs = loadRuns();
        runs.splice(idx, 1);
        saveRuns(runs);
        setStatus("Deleted one saved output.");
        setTimeout(()=>setStatus(""), 900);
      });
    });
  }

  clearSavedBtn.addEventListener("click", ()=>{
    localStorage.removeItem(MEM_KEY);
    renderSavedRuns();
    setStatus("Saved outputs cleared.");
    setTimeout(()=>setStatus(""), 1200);
  });

  // --------------------
  // Dictionary validation
  // --------------------
  const dictCache = new Map();

  async function isRealDictionaryWord(word){
    const w = normalizeWord(word);
    if(!w || w.length < 2) return false;
    if(dictCache.has(w)) return dictCache.get(w);

    try{
      const res = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(w)}`);
      const ok = res.ok;
      dictCache.set(w, ok);
      return ok;
    }catch(e){
      dictCache.set(w, false);
      return false;
    }
  }

  // --------------------
  // Datamuse expansions
  // --------------------
  async function dm(params){
    const url = `https://api.datamuse.com/words?${params}`;
    const res = await fetch(url);
    if(!res.ok) return [];
    return res.json();
  }

  function layerReasons(){
    return [
      { layer:"Apophenia", type:"mix", reason:(seed, w)=>`Apophenia: loose association from "${seed}" toward "${w}".` },
      { layer:"Phonosemantic", type:"sl", reason:(seed, w)=>`Phonosemantic: pronunciation / syllable sound from "${seed}" toward "${w}".` },
      { layer:"Phonetic Drift", type:"sl", reason:(seed, w)=>`Phonetic drift: sound-slide from "${seed}" toward "${w}".` },
      { layer:"Semiotic", type:"sp", reason:(seed, w)=>`Semiotic: glyph/shape pattern from "${seed}" toward "${w}".` },
      { layer:"Morphological", type:"sp", reason:(seed, w)=>`Morphological: structural reanalysis from "${seed}" toward "${w}".` },
      { layer:"Metaphorical", type:"ml", reason:(seed, w)=>`Metaphorical: meaning adjacency from "${seed}" toward "${w}".` },
      { layer:"Symbolic", type:"ml", reason:(seed, w)=>`Symbolic: archetypal association from "${seed}" toward "${w}".` },
      { layer:"Associative", type:"ml", reason:(seed, w)=>`Associative: spreading activation from "${seed}" toward "${w}".` },
      { layer:"Predictive", type:"ml", reason:(seed, w)=>`Predictive: narrative completion from "${seed}" toward "${w}".` },
    ];
  }

  function buildSeeds(word){
    const w = normalizeWord(word);
    const seeds = new Set();
    seeds.add(w);

    for(let i=0;i<w.length;i++){
      for(let j=i+3;j<=w.length;j++){
        seeds.add(w.slice(i,j));
      }
    }

    seeds.add(w.replace(/ph/g,"f"));
    seeds.add(w.replace(/c(?=[eiy])/g,"s"));
    seeds.add(w.replace(/tion/g,"shun"));
    seeds.add(w.replace(/[aeiou]/g,""));

    seeds.add(w.split("").reverse().join(""));
    seeds.add(w.replace(/w/g,"uu"));
    seeds.add(w.replace(/m/g,"nn"));

    const arr = [...seeds].filter(s=>s && s.length >= 2);
    arr.sort((a,b)=>b.length-a.length);
    return arr.slice(0, 18);
  }

  function score(word, meta){
    const w = normalizeWord(word);
    let s = 0;

    const layerCount = meta.layers.size;
    s += Math.min(0.35, (layerCount-1) * 0.10);

    if(meta.types.has("sl")) s += 0.12;
    if(meta.types.has("ml")) s += 0.10;
    if(meta.types.has("sp")) s += 0.08;

    const vowel = (w.match(/[aeiou]/g)||[]).length;
    s += Math.min(0.18, vowel * 0.03);

    if(w.length >= 4 && w.length <= 9) s += 0.12;
    if(w.length <= 3) s -= 0.10;

    if(state.used.has(w)) s -= 0.30;

    return Math.max(0, Math.min(1, s));
  }

  function mergeCandidate(word, layer, type, reason, seed){
    const w = normalizeWord(word);
    const s = normalizeWord(seed);
    if(!w) return;
    if(w === normalizeWord(state.inputWord)) return;

    if(!state.poolMeta.has(w)){
      state.poolMeta.set(w, {
        word: w,
        layers: new Set([layer]),
        types: new Set([type]),
        reasons: new Set([reason]),
        seedByType: new Map(s ? [[type, s]] : []),
      });
    } else {
      const m = state.poolMeta.get(w);
      m.layers.add(layer);
      m.types.add(type);
      m.reasons.add(reason);
      if(s && !m.seedByType.has(type)) m.seedByType.set(type, s);
    }
  }

  async function runOneGeneration(seedWords){
    const layers = layerReasons();
    const seeds = [];
    for(const sw of seedWords){
      buildSeeds(sw).forEach(s => seeds.push(s));
    }

    for(const L of layers){
      const seed = seeds[(state.seedCursor++) % seeds.length] || normalizeWord(state.inputWord);
      const cleanSeed = normalizeWord(seed);
      if(!cleanSeed || cleanSeed.length < 2) continue;

      let results = [];
      try{
        if(L.type === "sl"){
          results = await dm(`sl=${encodeURIComponent(cleanSeed)}&max=18`);
        } else if(L.type === "ml"){
          results = await dm(`ml=${encodeURIComponent(cleanSeed)}&max=18`);
        } else if(L.type === "sp"){
          const pattern = cleanSeed.length >= 4 ? `*${cleanSeed}*` : `${cleanSeed}*`;
          results = await dm(`sp=${encodeURIComponent(pattern)}&max=18`);
        } else {
          const a = await dm(`sl=${encodeURIComponent(cleanSeed)}&max=10`);
          const b = await dm(`ml=${encodeURIComponent(cleanSeed)}&max=10`);
          const c = await dm(`sp=${encodeURIComponent("*"+cleanSeed+"*")}&max=10`);
          results = [...a,...b,...c];
        }
      }catch(e){
        results = [];
      }

      for(const r of results){
        const cand = normalizeWord(r.word);
        if(!cand || cand.length < 3) continue;
        mergeCandidate(cand, L.layer, L.type, L.reason(cleanSeed, cand), cleanSeed);
      }
    }

    const all = [...state.poolMeta.values()].map(m => ({
      word: m.word,
      layers: m.layers,
      types: m.types,
      reasons: [...m.reasons],
      seedByType: m.seedByType,
      score: score(m.word, m),
      isNew: !state.used.has(m.word)
    }));

    all.sort((a,b)=> (b.score - a.score) || (b.layers.size - a.layers.size) || a.word.localeCompare(b.word));

    const batch = [];
    for(const item of all){
      if(batch.length >= PAGE_SIZE) break;
      if(state.used.has(item.word)) continue;
      batch.push(item);
      state.used.add(item.word);
    }

    const novelty = batch.length ? batch.filter(x=>x.isNew).length / batch.length : 0;
    return { batch, novelty };
  }

  function bestReason(item){
    const pref = item.reasons.find(r =>
      r.toLowerCase().includes("phonetic drift") ||
      r.toLowerCase().includes("phonosemantic") ||
      r.toLowerCase().includes("pronunciation")
    );
    return pref || item.reasons[0] || "Pattern derived.";
  }

  function anchorLine(item){
    const seedSound = item.seedByType?.get("sl");
    if(!seedSound) return "";
    return `
      <div class="tag-row" style="margin-top:10px;">
        <span class="tag bad" title="This token may be a drift midpoint rather than a strict dictionary headword.">
          Not in dictionary ‚Äî anchored to ${escapeHtml(seedSound.toUpperCase())}
        </span>
      </div>
    `;
  }

  function buildLinks(item){
    const w = item.word;

    const seedSound = item.seedByType?.get("sl");
    const dictDotComQuery = seedSound || w;
    const dictDotComLabel = seedSound ? "Dictionary.com (seed)" : "Dictionary.com";

    const wiktionaryHref = `https://en.wiktionary.org/wiki/${encodeURIComponent(w)}`;

    return `
      <div class="tag-row">
        <a class="tag brand-dict" rel="noopener noreferrer" target="_blank"
           href="https://www.dictionary.com/browse/${encodeURIComponent(dictDotComQuery)}">${dictDotComLabel}</a>

        <a class="tag brand-wikt" rel="noopener noreferrer" target="_blank"
           href="${wiktionaryHref}">Wiktionary (exact)</a>

        <a class="tag brand-wiki" rel="noopener noreferrer" target="_blank"
           href="https://en.wikipedia.org/w/index.php?search=${encodeURIComponent(w)}">Wikipedia</a>

        <a class="tag brand-yt" rel="noopener noreferrer" target="_blank"
           href="https://www.youtube.com/results?search_query=${encodeURIComponent(w)}">YouTube</a>

        <a class="tag brand-web" rel="noopener noreferrer" target="_blank"
           href="https://www.google.com/search?q=${encodeURIComponent(w)}">Web</a>
      </div>
    `;
  }

  function buildCard(item){
    const div = document.createElement("div");
    div.className = "card";
    div.style.borderLeft = "3px solid var(--accent)";
    div.id = "scorecard"; // NEW: stable anchor target

    div.innerHTML = `
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;">
        <div style="font-weight:1000; letter-spacing:1px;">
          PATTERN: <span class="mono">${escapeHtml(item.word.toUpperCase())}</span>
        </div>
        <div class="muted" style="font-size:0.8rem; font-weight:900;">
          SCORE: ${item.score.toFixed(2)}
        </div>
      </div>

      <p class="muted" style="margin:10px 0 0; font-size:0.98rem; line-height:1.5;">
        ${escapeHtml(bestReason(item))}
      </p>

      ${anchorLine(item)}
      ${buildLinks(item)}
    `;
    return div;
  }

  // FIXED: scroll AFTER DOM paints + use stable anchor (#scorecard)
  function openSingleCard(item){
  cardsArea.innerHTML = "";
  cardsArea.appendChild(buildCard(item));
  synthesisText.textContent = `"${item.word}" ‚Ä¢ ${bestReason(item)}`;
  scrollToScorecard();
}

function scrollToScorecard(){
  const hub = document.getElementById("feed-view");
  if(!hub) return;

  hub.scrollTo({
    top: hub.scrollHeight,
    behavior: "smooth"
  });
}


  function renderWordButtons(batch){
    wordListEl.innerHTML = "";
    batch.forEach(item=>{
      const btn = document.createElement("button");
      btn.className = "wordBtn";
      btn.textContent = item.word;
      btn.title = "Click to open";
      btn.addEventListener("click", ()=> openSingleCard(item));
      wordListEl.appendChild(btn);
    });
  }

  // --------------------
  // Execute / More / Clear
  // --------------------
  async function executeStack(){
    if(state.running) return;
    const raw = mainSearch.value.trim();
    if(!raw) return;

    state.running = true;
    executeBtn.disabled = true;
    moreBtn.disabled = true;
    saveBtn.disabled = true;

    setBadge("Checking dictionary‚Ä¶");
    setStatus("Validating input word (must be real)‚Ä¶");

    const ok = await isRealDictionaryWord(raw);
    if(!ok){
      setBadge("Not a dictionary word", "bad");
      setStatus("No run executed. Type a real dictionary word and try again.");
      state.running = false;
      executeBtn.disabled = false;
      return;
    }

    state.inputWord = raw;
    state.generation = 1;
    state.used = new Set();
    state.lastBatch = [];
    state.poolMeta = new Map();
    state.seedCursor = 0;

    displayWord.textContent = raw.toUpperCase();
    setBadge("Dictionary ‚úì", "good");
    setStatus("Running stack‚Ä¶");

    const { batch, novelty } = await runOneGeneration([raw]);
    state.lastBatch = batch;

    renderWordButtons(batch);

    cardsArea.innerHTML = "";
    synthesisText.textContent = `"${raw.toUpperCase()}" ready. Tap any generated word to open its card.`;

    setStatus(`Generated ${batch.length} words ‚Ä¢ gen ${state.generation} ‚Ä¢ novelty ${novelty.toFixed(2)}`);

    moreBtn.disabled = false;
    saveBtn.disabled = false;
    state.running = false;
    executeBtn.disabled = false;
  }

  async function generateMore(){
    if(state.running) return;
    if(!state.lastBatch.length) return;

    state.running = true;
    moreBtn.disabled = true;

    const seedWords = state.lastBatch.slice(0, 10).map(x=>x.word);
    setStatus("Expanding outward‚Ä¶");

    state.generation += 1;
    const { batch, novelty } = await runOneGeneration(seedWords);

    if(!batch.length || novelty < NOVELTY_MIN){
      setStatus("Natural stop point reached: no new high-novelty patterns remain.");
      moreBtn.disabled = true;
      state.running = false;
      return;
    }

    state.lastBatch = batch;
    renderWordButtons(batch);

    cardsArea.innerHTML = "";
    synthesisText.textContent = `"${state.inputWord.toUpperCase()}" expanded. Tap a word to open its card.`;

    setStatus(`Generated ${batch.length} words ‚Ä¢ gen ${state.generation} ‚Ä¢ novelty ${novelty.toFixed(2)}`);

    moreBtn.disabled = false;
    state.running = false;
  }

  function clearOutput(){
    state.inputWord = "";
    state.generation = 0;
    state.used = new Set();
    state.lastBatch = [];
    state.poolMeta = new Map();
    state.seedCursor = 0;

    displayWord.textContent = "‚Äî";
    wordListEl.innerHTML = "";
    cardsArea.innerHTML = "";
    synthesisText.textContent = `"The engine identifies patterns. The human determines truth."`;

    setBadge("Awaiting input‚Ä¶");
    setStatus("Cleared. Type a word and press Execute.");

    moreBtn.disabled = true;
    saveBtn.disabled = true;

    mainSearch.value = "";
    mainSearch.focus();
  }

  function saveCurrent(){
    if(!state.inputWord || !state.lastBatch.length) return;

    addRun({
      word: state.inputWord.toUpperCase(),
      createdAt: new Date().toISOString(),
      generation: state.generation,
      results: state.lastBatch.map(x=>({
        word: x.word,
        reasons: x.reasons.slice(0,2),
        score: x.score,
        anchor: x.seedByType?.get("sl") || ""
      }))
    });

    setStatus("Saved output to Notes.");
    setTimeout(()=>setStatus(`Generated ${state.lastBatch.length} words ‚Ä¢ gen ${state.generation}`), 1200);
  }

  executeBtn.addEventListener("click", executeStack);
  moreBtn.addEventListener("click", generateMore);
  clearBtn.addEventListener("click", clearOutput);
  saveBtn.addEventListener("click", saveCurrent);

  mainSearch.addEventListener("keydown", (e)=>{
    if(e.key === "Enter") executeStack();
  });

  // --------------------
  // Mobile view switcher
  // --------------------
  function showView(id) {
    const views = ['notes-view', 'feed-view'];
    views.forEach(v => {
      const el = document.getElementById(v);
      if (window.innerWidth <= 1024) {
        el.style.display = (v === id) ? 'block' : 'none';
      }
    });
  }
  window.showView = showView;

  window.addEventListener('resize', () => {
    if (window.innerWidth > 1024) {
      ['notes-view', 'feed-view'].forEach(id => {
        document.getElementById(id).style.display = 'block';
      });
    }
  });

  // Boot
  renderSavedRuns();
  clearOutput();
</script>

</body>
</html>
